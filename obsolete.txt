/**
     * Reads a word from the current postion in the current string
     */
    private String readWord()
    {
        seek();
        if (canAdvance())
        {
            String word = "";
            char character = activeLine.charAt(linePos);
            while(Character.isLetterOrDigit(character))
            {
                word += character;
                advance();
                character = activeLine.charAt(linePos);
            }
            return word;
        }
        return null;
    }
	
/**
     * Simplifies the source code into a chain of Figures
     */
    private void simplify()
    {
        while (canAdvance())
        {
            seek();
            if (Character.isLetterOrDigit(activeLine.charAt(linePos)))
            {
                String word = readWord();
                //System.out.print(word + " ");
                simp.add(new Figure(word,Figure.FigureType.WORD));
            }
            else
            {
                String symb = activeLine.substring(linePos,linePos+1);
                //System.out.print(symb);
                simp.add(new Figure(symb,Figure.FigureType.SYMBOL));
                advance();
            }
        }
    }
	
	/**
     * version of scanFig that ignores quotes
     */
    private void scanFigNQ()
    {
        while (figPos < simp.size())
        {
            if (simp.get(figPos).getType() == Figure.FigureType.SYMBOL)
            {
                String symbol = simp.get(figPos).getText();
                //if a quotation is found, dont scan data until next quote
                if (symbol.equals("\"") || symbol.equals("\'"))
                {
                    boolean flag = true;
                    while (flag)
                    {
                        figPos++;
                        //ensures that found quote is not a control quote
                        if (simp.get(figPos).getText().equals(symbol))
                        {
                            if (simp.get(figPos-1).getText().equals("\\"))
                            {
                                if (simp.get(figPos-2).getText().equals("\\"))
                                    flag = false;
                                else
                                    flag = true;
                            }
                            else
                                flag = false;
                        }
                    }
                }
            }
            else if (simp.get(figPos).getType() == Figure.FigureType.WORD)
            {
                String word = simp.get(figPos).getText();
                if (word.equals("import"))
                {
                    //imported classes
                    figPos++;
                    word = simp.get(figPos).getText();
                    while (!simp.get(figPos+1).getText().equals(";"))
                    {
                        figPos++;
                        word = simp.get(figPos).getText();
                    }
                    String name = simp.get(figPos).getText();
                    //IMPORT
                    dataTypes.add(name);
                    figPos++;
                    System.out.println("IMPORT: " + name);
                }
                else if (word.equals("new"))
                {
                    do
                    {
                        figPos++;
                    } while (!simp.get(figPos).getText().equals(";"));
                }
                else
                {
                    //method/variable declaration
                    //ignores access type
                    if (word.equals("public") || word.equals("private") || word.equals("protected"))
                        word = simp.get(++figPos).getText();
                    if (word.equals("static"))
                        word = simp.get(++figPos).getText();
                    //checks if dataType is detected
                    if (checkDataType(word))
                    {
                        figPos++;
                        //ignores contstructors
                        if (!simp.get(figPos).getText().equals("("))
                        {
                            //ignores generics
                            if (simp.get(figPos).getText().equals("<"))
                                figPos += 3;
                            Figure fig = simp.get(figPos);
                            while (fig.getType() == Figure.FigureType.SYMBOL)
                            {
                                figPos++;
                                fig = simp.get(figPos);
                            }
                            String name = fig.getText();
                            figPos++;
                            //determines if the line is a method or a variable
                            if (simp.get(figPos).getText().equals("("))
                            {
                                //method declaration
                                methods.add(name);
                                //cypher.add(new Cypher(name));
                                addCypher(name);
                                figPos++;
                                System.out.println("MTDDEC: " + name + " (" + word + ")");
                            }
                            else
                            {
                                //variable declaration
                                variables.add(name);
                                //cypher.add(new Cypher(name));
                                addCypher(name);
                                figPos++;
                                System.out.println("VARDEC: " + name + " (" + word + ")");
                            }
                        }
                    }
                    else if (word.equals("class"))
                    {
                        //class declaration
                        //CLASSDEC
                        figPos++;
                        String name = simp.get(figPos).getText();
                        figPos++;
                        dataTypes.add(name);
                        //cypher.add(new Cypher(name));
                        addCypher(name);
                        System.out.println("CLSDEC: " + name);
                        while (simp.get(figPos).getType() != Figure.FigureType.SYMBOL)
                            figPos++;
                    }
                    else
                    {
                        figPos++;
                    }
                }
            }
        }
    }
	
	/**
     * Seeks to non-white space
     */
    private void seek()
    {
        boolean cont = true;
        boolean flag;
        while (cont)
        {
            if (linePos >= activeLine.length())
                nextLine();
            switch (activeLine.charAt(linePos))
            {
                case ' ':
                    advance();
                    break;
                //ignores comments
                case '/':
                    //determines if the slash could be a comment
                    if (linePos + 1 < activeLine.length())
                    {
                        //determines if the slash is a single or multiline comment, or not a comment
                        if (activeLine.charAt(linePos+1) == '/')
                        {
                            //skips to the next line
                            nextLine();
                        }
                        else if (activeLine.charAt(linePos+1) == '*')
                        {
                            //ignores all data until the end of the multiline comment
                            advance(); advance();
                            flag = true;
                            while (flag)
                            {
                                //checks if next two characters are the end of the comment
                                if (linePos + 1 < activeLine.length()
                                && activeLine.charAt(linePos) == '*'
                                && activeLine.charAt(linePos+1) == '/')
                                    {advance(); advance(); flag = false;}
                                else
                                {
                                    //continues
                                    advance();
                                    if (!canAdvance())
                                    {
                                        flag = false;
                                        cont = false;
                                    }
                                }
                            }
                        }
                        else
                            cont = false;
                    }
                    else
                        cont = false;
                    break;
                //ignores quotes
                case '\"':
                    advance();
                    flag = true;
                    while (flag)
                    {
                        //checks for the end quote
                        if (linePos < activeLine.length()
                        && activeLine.charAt(linePos) == '\"')
                        {advance(); flag = false;}
                        else
                        {
                            //continues
                            advance();
                            if (!canAdvance())
                            {
                                flag = false;
                                cont = false;
                            }
                        }
                    }
                    break;
                case '\'':
                    advance();
                    flag = true;
                    while (flag)
                    {
                        //checks for the end quote
                        if (linePos < activeLine.length()
                        && activeLine.charAt(linePos) == '\'')
                        {advance(); flag = false;}
                        else
                        {
                            //continues
                            advance();
                            if (!canAdvance())
                            {
                                flag = false;
                                cont = false;
                            }
                        }
                    }
                    break;
                default:
                    cont = false;
            }
        }
    }